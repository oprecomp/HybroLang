/* Begin Header autogenerated part */
#include "h2-riscv-RV32G.h"
#define riscv_G32(INSN){ *(h2_asm_pc++) = (INSN);}

void RV32I_RET__I_32(void){ /* RET */
#ifdef H2_DEBUG
    printf("%p : RV32I_RET__I_32\n", h2_asm_pc);
#endif
	riscv_G32(((0x8067 >> 0) & 0xffffffff)); \
}  

void RV32M_MUL_RRR_I_32(int r3, int r1, int r2){ /* MUL */
#ifdef H2_DEBUG
    printf("%p : RV32M_MUL_RRR_I_32\n", h2_asm_pc);
#endif
	riscv_G32(((0x1 & 0x7f) << 25)|((r2 & 0x1f) << 20)|((r1 & 0x1f) << 15)|((0x0 & 0x7) << 12)|((r3 & 0x1f) << 7)|((0x33 & 0x7f) >> 0)); \
}  

void RV32M_DIV_RRR_I_32(int r3, int r1, int r2){ /* DIV */
#ifdef H2_DEBUG
    printf("%p : RV32M_DIV_RRR_I_32\n", h2_asm_pc);
#endif
	riscv_G32(((0x1 & 0x7f) << 25)|((r2 & 0x1f) << 20)|((r1 & 0x1f) << 15)|((0x4 & 0x7) << 12)|((r3 & 0x1f) << 7)|((0x33 & 0x7f) >> 0)); \
}  

void RV32I_SUB_RRR_I_32(int r3, int r1, int r2){ /* SUB */
#ifdef H2_DEBUG
    printf("%p : RV32I_SUB_RRR_I_32\n", h2_asm_pc);
#endif
	riscv_G32(((0x20 & 0x7f) << 25)|((r2 & 0x1f) << 20)|((r1 & 0x1f) << 15)|((0x0 & 0x7) << 12)|((r3 & 0x1f) << 7)|((0x33 & 0x7f) >> 0)); \
}  

void RV32I_MV_RR_I_32(int r0, int r1){ /* MV */
#ifdef H2_DEBUG
    printf("%p : RV32I_MV_RR_I_32\n", h2_asm_pc);
#endif
	riscv_G32(((0x0 & 0xfff) << 20)|((r1 & 0x1f) << 15)|((0x0 & 0x7) << 12)|((r0 & 0x1f) << 7)|((0x13 & 0x7f) >> 0)); \
}  

void RV32I_MV_RI_I_32(int r3, int i1){ /* MV */
#ifdef H2_DEBUG
    printf("%p : RV32I_MV_RI_I_32\n", h2_asm_pc);
#endif
	riscv_G32(((i1 & 0xfff) << 20)|((0x6 & 0xff) << 12)|((r3 & 0x1f) << 7)|((0x13 & 0x7f) >> 0)); \
}  

void RV32I_ADDI_RRI_I_32(int r1, int r0, int i0){ /* ADD */
#ifdef H2_DEBUG
    printf("%p : RV32I_ADDI_RRI_I_32\n", h2_asm_pc);
#endif
	riscv_G32(((i0 & 0xfff) << 20)|((r0 & 0x1f) << 15)|((0x0 & 0x7) << 12)|((r1 & 0x1f) << 7)|((0x13 & 0x7f) >> 0)); \
}  

void RV32I_ADD_RRR_I_32(int r3, int r1, int r2){ /* ADD */
#ifdef H2_DEBUG
    printf("%p : RV32I_ADD_RRR_I_32\n", h2_asm_pc);
#endif
	riscv_G32(((0x0 & 0x7f) << 25)|((r2 & 0x1f) << 20)|((r1 & 0x1f) << 15)|((0x0 & 0x7) << 12)|((r3 & 0x1f) << 7)|((0x33 & 0x7f) >> 0)); \
}  
void riscv_genMUL_3(h2_sValue_t P0, h2_sValue_t P1, h2_sValue_t P2)
{

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
        RV32M_MUL_RRR_I_32(P0.regNro, P1.regNro, P2.regNro);
    }
    
    else
    {
        printf("Warning, generation of MUL is not possible with this arguments P0: %c, %i, %i,  P0: %i , P1: %i , P2: %i \n", P0.arith, P0.wLen, P0.vLen, P0.ValOrReg ,P1.ValOrReg ,P2.ValOrReg);
        h2_codeGenerationOK = 0;
    }
}
void riscv_genMUL_4(h2_sValue_t P0, h2_sValue_t P1, h2_sValue_t P2, h2_sValue_t P3)
{

    printf("Warning, generation of MUL is not possible with this arguments P0: %c, %i, %i,  P0: %i , P1: %i , P2: %i , P3: %i \n", P0.arith, P0.wLen, P0.vLen, P0.ValOrReg ,P1.ValOrReg ,P2.ValOrReg ,P3.ValOrReg);
    h2_codeGenerationOK = 0;

}
void riscv_genDIV_3(h2_sValue_t P0, h2_sValue_t P1, h2_sValue_t P2)
{

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
        RV32M_DIV_RRR_I_32(P0.regNro, P1.regNro, P2.regNro);
    }
    
    else
    {
        printf("Warning, generation of DIV is not possible with this arguments P0: %c, %i, %i,  P0: %i , P1: %i , P2: %i \n", P0.arith, P0.wLen, P0.vLen, P0.ValOrReg ,P1.ValOrReg ,P2.ValOrReg);
        h2_codeGenerationOK = 0;
    }
}
void riscv_genDIV_4(h2_sValue_t P0, h2_sValue_t P1, h2_sValue_t P2, h2_sValue_t P3)
{

    printf("Warning, generation of DIV is not possible with this arguments P0: %c, %i, %i,  P0: %i , P1: %i , P2: %i , P3: %i \n", P0.arith, P0.wLen, P0.vLen, P0.ValOrReg ,P1.ValOrReg ,P2.ValOrReg ,P3.ValOrReg);
    h2_codeGenerationOK = 0;

}
void riscv_genRET_0()
{

    RV32I_RET__I_32();

}
void riscv_genSUB_3(h2_sValue_t P0, h2_sValue_t P1, h2_sValue_t P2)
{

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
        RV32I_SUB_RRR_I_32(P0.regNro, P1.regNro, P2.regNro);
    }
    
    else
    {
        printf("Warning, generation of SUB is not possible with this arguments P0: %c, %i, %i,  P0: %i , P1: %i , P2: %i \n", P0.arith, P0.wLen, P0.vLen, P0.ValOrReg ,P1.ValOrReg ,P2.ValOrReg);
        h2_codeGenerationOK = 0;
    }
}
void riscv_genMV_2(h2_sValue_t P0, h2_sValue_t P1)
{

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER)
    {
        RV32I_MV_RR_I_32(P0.regNro, P1.regNro);
    }
    
    else if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == VALUE)
    {
        RV32I_MV_RI_I_32(P0.regNro, P1.valueImm);
    }
    
    else
    {
        printf("Warning, generation of MV is not possible with this arguments P0: %c, %i, %i,  P0: %i , P1: %i \n", P0.arith, P0.wLen, P0.vLen, P0.ValOrReg ,P1.ValOrReg);
        h2_codeGenerationOK = 0;
    }
}
void riscv_genADD_3(h2_sValue_t P0, h2_sValue_t P1, h2_sValue_t P2)
{

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == VALUE)
    {
        RV32I_ADDI_RRI_I_32(P0.regNro, P1.regNro, P2.valueImm);
    }
    
    else if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
        RV32I_ADD_RRR_I_32(P0.regNro, P1.regNro, P2.regNro);
    }
    
    else
    {
        printf("Warning, generation of ADD is not possible with this arguments P0: %c, %i, %i,  P0: %i , P1: %i , P2: %i \n", P0.arith, P0.wLen, P0.vLen, P0.ValOrReg ,P1.ValOrReg ,P2.ValOrReg);
        h2_codeGenerationOK = 0;
    }
}

/* End Header autogenerated part */
// -*- c -*-
#include <stdio.h>
#include <stdlib.h>

typedef  int (*pifi)(int);

h2_insn_t * genC2F(h2_insn_t * ptr)
{
/* Code Generation of 3 instructions */
/* Symbol table :*/
	/*VarName = { ValOrLen, arith, vectorLen, wordLen, regNo, Value} */
	h2_sValue_t a = {REGISTER, 'i', 1, 32, 10, 0};
	h2_sValue_t h2_outputVarName = {REGISTER, 'i', 1, 32, 10, 0};
	h2_sValue_t r = {REGISTER, 'i', 1, 32, 5, 0};
	h2_sValue_t h2_00000000 = {REGISTER, 'i', 1, 32, 6, 0};
	h2_sValue_t h2_00000001 = {REGISTER, 'i', 1, 32, 7, 0};


/* Label  table :*/
#define riscv_genLABEL(LABEL_ID) labelAddresses[LABEL_ID] = h2_asm_pc;
h2_insn_t   * labelAddresses []={
	};


	h2_asm_pc = (h2_insn_t *) ptr;
	h2_codeGenerationOK = 1;
	riscv_genMV_2(h2_00000000, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, 9});
	riscv_genMUL_3(h2_00000000, a, h2_00000000);
	riscv_genMV_2(h2_00000001, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, 5});
	riscv_genDIV_3(h2_00000000, h2_00000000, h2_00000001);
	riscv_genMV_2(h2_00000001, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, 32});
	riscv_genADD_3(h2_00000000, h2_00000000, h2_00000001);
	riscv_genMV_2(r, h2_00000000);
	riscv_genMV_2(h2_outputVarName, r);
	riscv_genRET_0();
	/* Call back code for loops */
	h2_save_asm_pc = h2_asm_pc;
	h2_asm_pc = h2_save_asm_pc;
	iflush(ptr, h2_asm_pc);

  return (h2_insn_t *) ptr;
}

h2_insn_t * genF2C(h2_insn_t * ptr)
{
/* Code Generation of 3 instructions */
/* Symbol table :*/
	/*VarName = { ValOrLen, arith, vectorLen, wordLen, regNo, Value} */
	h2_sValue_t a = {REGISTER, 'i', 1, 32, 10, 0};
	h2_sValue_t h2_outputVarName = {REGISTER, 'i', 1, 32, 10, 0};
	h2_sValue_t r = {REGISTER, 'i', 1, 32, 5, 0};
	h2_sValue_t h2_00000000 = {REGISTER, 'i', 1, 32, 6, 0};
	h2_sValue_t h2_00000001 = {REGISTER, 'i', 1, 32, 7, 0};


/* Label  table :*/
#define riscv_genLABEL(LABEL_ID) labelAddresses[LABEL_ID] = h2_asm_pc;
h2_insn_t   * labelAddresses []={
	};


	h2_asm_pc = (h2_insn_t *) ptr;
	h2_codeGenerationOK = 1;
	riscv_genMV_2(h2_00000000, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, 160});
	riscv_genMV_2(h2_00000001, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, 9});
	riscv_genDIV_3(h2_00000000, h2_00000000, h2_00000001);
	riscv_genSUB_3(h2_00000000, a, h2_00000000);
	riscv_genMV_2(r, h2_00000000);
	riscv_genMV_2(h2_outputVarName, r);
	riscv_genRET_0();
	/* Call back code for loops */
	h2_save_asm_pc = h2_asm_pc;
	h2_asm_pc = h2_save_asm_pc;
	iflush(ptr, h2_asm_pc);

  return (h2_insn_t *) ptr;
}


int main(int argc, char * argv[])
{
  h2_insn_t * ptr;
  int in0, res, resultOK;
  pifi fC2F, fF2C;

  resultOK = 0;
  if (argc < 2)
    {
      printf("Give 1 values\n");
      exit(-1);
    }
  in0  = atoi (argv[1]);   // Get the users values in0
  printf("// Compilette for conversion from celcius to farenheit\n");
  ptr  = h2_malloc (1024);  // Allocate memory for 1024 instructions
  fC2F = (pifi) genC2F (ptr); //
  res  = fC2F(in0);  // Call generated code
  printf("%d (celcius)   -> (farenheit)%d\n", in0, res);
  if (res != (in0 * 9 / 5 + 32))
	resultOK += 1;
  printf("// Compilette for conversion from farenheit to celcius\n");
  ptr  = h2_malloc (1024);  // Allocate memory for 1024 instructions
  fF2C = (pifi) genF2C (ptr); //
  res  = fF2C(in0);  // Call generated code
  printf("%d (farenheit)   -> (celcius)%d\n", in0, res);
  if (res != (in0 - 32 * 5 / 9))
	resultOK += 1;

  if (resultOK == 0)
	return 0;
  else
	return -1;
}
