/* Begin Header autogenerated part */
#include "h2-power-power.h"
#define power_G32(INSN){ *(h2_asm_pc++) = (INSN);}

void P1_BLR__I_32(void){ /* ret */
#ifdef H2_DEBUG
    printf("%p : P1_BLR__I_32\n", h2_asm_pc);
#endif
	power_G32(((0x4e800020 >> 0) & 0xffffffff)); \
}  

void P1_MULLW_RRR_I_32(int r0, int r1, int r2){ /* mul */
#ifdef H2_DEBUG
    printf("%p : P1_MULLW_RRR_I_32\n", h2_asm_pc);
#endif
	power_G32(((0x1f & 0x3f) << 26)|((r0 & 0x1f) << 21)|((r1 & 0x1f) << 16)|((r2 & 0x1f) << 11)|((0x1d6 & 0x7ff) >> 0)); \
}  

void P1_MULLI_RRI_I_64(int r0, int r1, int i0){ /* mul */
#ifdef H2_DEBUG
    printf("%p : P1_MULLI_RRI_I_64\n", h2_asm_pc);
#endif
	power_G32(((0x7 & 0x3f) << 26)|((r0 & 0x1f) << 21)|((r1 & 0x1f) << 16)|((i0 & 0xffff) >> 0)); \
}  

void P1_SUBI_RRI_I_32(int r0, int r1, int i0){ /* sub */
#ifdef H2_DEBUG
    printf("%p : P1_SUBI_RRI_I_32\n", h2_asm_pc);
#endif
	power_G32(((0xe & 0x3f) << 26)|((r0 & 0x1f) << 21)|((r1 & 0x1f) << 16)|((-i0 & 0xffff) >> 0)); \
}  

void PPC_SUB_RRR_I_32(int r0, int r2, int r1){ /* sub */
#ifdef H2_DEBUG
    printf("%p : PPC_SUB_RRR_I_32\n", h2_asm_pc);
#endif
	power_G32(((0x1f & 0x3f) << 26)|((r0 & 0x1f) << 21)|((r1 & 0x1f) << 16)|((r2 & 0x1f) << 11)|((0x50 & 0x7ff) >> 0)); \
}  

void V2_03_VADDSBS_RRR_I_8(int r0, int r1, int r2){ /* add */
#ifdef H2_DEBUG
    printf("%p : V2_03_VADDSBS_RRR_I_8\n", h2_asm_pc);
#endif
	power_G32(((0x4 & 0x3f) << 26)|((r0 & 0x1f) << 21)|((r1 & 0x1f) << 16)|((r2 & 0x1f) << 11)|((0x300 & 0x7ff) >> 0)); \
}  

void V2_03_VADDUBS_RRR_I_8(int r0, int r1, int r2){ /* add */
#ifdef H2_DEBUG
    printf("%p : V2_03_VADDUBS_RRR_I_8\n", h2_asm_pc);
#endif
	power_G32(((0x4 & 0x3f) << 26)|((r0 & 0x1f) << 21)|((r1 & 0x1f) << 16)|((r2 & 0x1f) << 11)|((0x200 & 0x7ff) >> 0)); \
}  

void V2_03_VADDUHS_RRR_I_16(int r0, int r1, int r2){ /* add */
#ifdef H2_DEBUG
    printf("%p : V2_03_VADDUHS_RRR_I_16\n", h2_asm_pc);
#endif
	power_G32(((0x4 & 0x3f) << 26)|((r0 & 0x1f) << 21)|((r1 & 0x1f) << 16)|((r2 & 0x1f) << 11)|((0x240 & 0x7ff) >> 0)); \
}  

void V2_03_VADDSHS_RRR_I_16(int r0, int r1, int r2){ /* add */
#ifdef H2_DEBUG
    printf("%p : V2_03_VADDSHS_RRR_I_16\n", h2_asm_pc);
#endif
	power_G32(((0x4 & 0x3f) << 26)|((r0 & 0x1f) << 21)|((r1 & 0x1f) << 16)|((r2 & 0x1f) << 11)|((0x340 & 0x7ff) >> 0)); \
}  

void V2_03_VADDUWS_RRR_I_32(int r0, int r1, int r2){ /* add */
#ifdef H2_DEBUG
    printf("%p : V2_03_VADDUWS_RRR_I_32\n", h2_asm_pc);
#endif
	power_G32(((0x4 & 0x3f) << 26)|((r0 & 0x1f) << 21)|((r1 & 0x1f) << 16)|((r2 & 0x1f) << 11)|((0x280 & 0x7ff) >> 0)); \
}  

void P1_ADDI_RRI_I_32(int r0, int r1, int i0){ /* add */
#ifdef H2_DEBUG
    printf("%p : P1_ADDI_RRI_I_32\n", h2_asm_pc);
#endif
	power_G32(((0xe & 0x3f) << 26)|((r0 & 0x1f) << 21)|((r1 & 0x1f) << 16)|((i0 & 0xffff) >> 0)); \
}  

void V2_03_VADDSWS_RRR_I_32(int r0, int r1, int r2){ /* add */
#ifdef H2_DEBUG
    printf("%p : V2_03_VADDSWS_RRR_I_32\n", h2_asm_pc);
#endif
	power_G32(((0x4 & 0x3f) << 26)|((r0 & 0x1f) << 21)|((r1 & 0x1f) << 16)|((r2 & 0x1f) << 11)|((0x380 & 0x7ff) >> 0)); \
}  

void P1_ADD_RRR_I_32(int r0, int r1, int r2){ /* add */
#ifdef H2_DEBUG
    printf("%p : P1_ADD_RRR_I_32\n", h2_asm_pc);
#endif
	power_G32(((0x1f & 0x3f) << 26)|((r0 & 0x1f) << 21)|((r1 & 0x1f) << 16)|((r2 & 0x1f) << 11)|((0x214 & 0x7ff) >> 0)); \
}  

void P1_LI_RI_I_32(int r0, int i0){ /* mv */
#ifdef H2_DEBUG
    printf("%p : P1_LI_RI_I_32\n", h2_asm_pc);
#endif
	power_G32(((0xe & 0x3f) << 26)|((r0 & 0x1f) << 21)|((0x0 & 0x1f) << 16)|((i0 & 0xffff) >> 0)); \
}  

void P1_MV_RR_I_32(int r0, int r1){ /* mv */
#ifdef H2_DEBUG
    printf("%p : P1_MV_RR_I_32\n", h2_asm_pc);
#endif
	power_G32(((0xe & 0x3f) << 26)|((r0 & 0x1f) << 21)|((r1 & 0x1f) << 16)|((0x0 & 0xffff) >> 0)); \
}  

void PPC_DIVW_RRR_I_32(int r0, int r1, int r2){ /* div */
#ifdef H2_DEBUG
    printf("%p : PPC_DIVW_RRR_I_32\n", h2_asm_pc);
#endif
	power_G32(((0x1f & 0x3f) << 26)|((r0 & 0x1f) << 21)|((r1 & 0x1f) << 16)|((r2 & 0x1f) << 11)|((0x3d6 & 0x7ff) >> 0)); \
}  

void PPC_DIVD_RRR_I_64(int r0, int r1, int r2){ /* div */
#ifdef H2_DEBUG
    printf("%p : PPC_DIVD_RRR_I_64\n", h2_asm_pc);
#endif
	power_G32(((0x1f & 0x3f) << 26)|((r0 & 0x1f) << 21)|((r1 & 0x1f) << 16)|((r2 & 0x1f) << 11)|((0x3d2 & 0x7ff) >> 0)); \
}  

void PPC_DIVD__RRR_I_64(int r0, int r1, int r2){ /* div */
#ifdef H2_DEBUG
    printf("%p : PPC_DIVD__RRR_I_64\n", h2_asm_pc);
#endif
	power_G32(((0x1f & 0x3f) << 26)|((r0 & 0x1f) << 21)|((r1 & 0x1f) << 16)|((r2 & 0x1f) << 11)|((0x3d3 & 0x7ff) >> 0)); \
}  

void PPC_DIVDO_RRR_I_64(int r0, int r1, int r2){ /* div */
#ifdef H2_DEBUG
    printf("%p : PPC_DIVDO_RRR_I_64\n", h2_asm_pc);
#endif
	power_G32(((0x1f & 0x3f) << 26)|((r0 & 0x1f) << 21)|((r1 & 0x1f) << 16)|((r2 & 0x1f) << 11)|((0x7d2 & 0x7ff) >> 0)); \
}  

void PPC_DIVDO__RRR_I_64(int r0, int r1, int r2){ /* div */
#ifdef H2_DEBUG
    printf("%p : PPC_DIVDO__RRR_I_64\n", h2_asm_pc);
#endif
	power_G32(((0x1f & 0x3f) << 26)|((r0 & 0x1f) << 21)|((r1 & 0x1f) << 16)|((r2 & 0x1f) << 11)|((0x7d3 & 0x7ff) >> 0)); \
}  
void power_genRET_0()
{

    P1_BLR__I_32();

}
void power_genSUB_3(h2_sValue_t P0, h2_sValue_t P1, h2_sValue_t P2)
{

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == VALUE)
    {
        P1_SUBI_RRI_I_32(P0.regNro, P1.regNro, P2.valueImm);
    }
    
    else if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
        PPC_SUB_RRR_I_32(P0.regNro, P1.regNro, P2.regNro);
    }
    
    else
    {
        printf("Warning, generation of SUB is not possible with this arguments P0: %c, %i, %i,  P0: %i , P1: %i , P2: %i \n", P0.arith, P0.wLen, P0.vLen, P0.ValOrReg ,P1.ValOrReg ,P2.ValOrReg);
        h2_codeGenerationOK = 0;
    }
}
void power_genMUL_3(h2_sValue_t P0, h2_sValue_t P1, h2_sValue_t P2)
{

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
        P1_MULLW_RRR_I_32(P0.regNro, P1.regNro, P2.regNro);
    }
    
    else if ((P0.arith == 'i') && (P0.wLen <= 64) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == VALUE)
    {
        P1_MULLI_RRI_I_64(P0.regNro, P1.regNro, P2.valueImm);
    }
    
    else
    {
        printf("Warning, generation of MUL is not possible with this arguments P0: %c, %i, %i,  P0: %i , P1: %i , P2: %i \n", P0.arith, P0.wLen, P0.vLen, P0.ValOrReg ,P1.ValOrReg ,P2.ValOrReg);
        h2_codeGenerationOK = 0;
    }
}
void power_genADD_3(h2_sValue_t P0, h2_sValue_t P1, h2_sValue_t P2)
{

    if ((P0.arith == 'i') && (P0.wLen <= 8) && (P0.vLen == 16) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
        V2_03_VADDSBS_RRR_I_8(P0.regNro, P1.regNro, P2.regNro);
    }
    
    else if ((P0.arith == 'i') && (P0.wLen <= 8) && (P0.vLen == 16) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
        V2_03_VADDUBS_RRR_I_8(P0.regNro, P1.regNro, P2.regNro);
    }
    
    else if ((P0.arith == 'i') && (P0.wLen <= 16) && (P0.vLen == 8) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
        V2_03_VADDUHS_RRR_I_16(P0.regNro, P1.regNro, P2.regNro);
    }
    
    else if ((P0.arith == 'i') && (P0.wLen <= 16) && (P0.vLen == 8) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
        V2_03_VADDSHS_RRR_I_16(P0.regNro, P1.regNro, P2.regNro);
    }
    
    else if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 4) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
        V2_03_VADDUWS_RRR_I_32(P0.regNro, P1.regNro, P2.regNro);
    }
    
    else if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == VALUE)
    {
        P1_ADDI_RRI_I_32(P0.regNro, P1.regNro, P2.valueImm);
    }
    
    else if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 4) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
        V2_03_VADDSWS_RRR_I_32(P0.regNro, P1.regNro, P2.regNro);
    }
    
    else if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
        P1_ADD_RRR_I_32(P0.regNro, P1.regNro, P2.regNro);
    }
    
    else
    {
        printf("Warning, generation of ADD is not possible with this arguments P0: %c, %i, %i,  P0: %i , P1: %i , P2: %i \n", P0.arith, P0.wLen, P0.vLen, P0.ValOrReg ,P1.ValOrReg ,P2.ValOrReg);
        h2_codeGenerationOK = 0;
    }
}
void power_genMV_2(h2_sValue_t P0, h2_sValue_t P1)
{

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == VALUE)
    {
        P1_LI_RI_I_32(P0.regNro, P1.valueImm);
    }
    
    else if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER)
    {
        P1_MV_RR_I_32(P0.regNro, P1.regNro);
    }
    
    else
    {
        printf("Warning, generation of MV is not possible with this arguments P0: %c, %i, %i,  P0: %i , P1: %i \n", P0.arith, P0.wLen, P0.vLen, P0.ValOrReg ,P1.ValOrReg);
        h2_codeGenerationOK = 0;
    }
}
void power_genDIV_3(h2_sValue_t P0, h2_sValue_t P1, h2_sValue_t P2)
{

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
        PPC_DIVW_RRR_I_32(P0.regNro, P1.regNro, P2.regNro);
    }
    
    else if ((P0.arith == 'i') && (P0.wLen <= 64) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
        PPC_DIVD_RRR_I_64(P0.regNro, P1.regNro, P2.regNro);
    }
    
    else if ((P0.arith == 'i') && (P0.wLen <= 64) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
        PPC_DIVD__RRR_I_64(P0.regNro, P1.regNro, P2.regNro);
    }
    
    else if ((P0.arith == 'i') && (P0.wLen <= 64) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
        PPC_DIVDO_RRR_I_64(P0.regNro, P1.regNro, P2.regNro);
    }
    
    else if ((P0.arith == 'i') && (P0.wLen <= 64) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
        PPC_DIVDO__RRR_I_64(P0.regNro, P1.regNro, P2.regNro);
    }
    
    else
    {
        printf("Warning, generation of DIV is not possible with this arguments P0: %c, %i, %i,  P0: %i , P1: %i , P2: %i \n", P0.arith, P0.wLen, P0.vLen, P0.ValOrReg ,P1.ValOrReg ,P2.ValOrReg);
        h2_codeGenerationOK = 0;
    }
}

/* End Header autogenerated part */
// -*- c -*-
#include <stdio.h>
#include <stdlib.h>

typedef  int (*pifi)(int);

h2_insn_t * genC2F(h2_insn_t * ptr)
{
/* Code Generation of 3 instructions */
/* Symbol table :*/
	/*VarName = { ValOrLen, arith, vectorLen, wordLen, regNo, Value} */
	h2_sValue_t a = {REGISTER, 'i', 1, 32, 3, 0};
	h2_sValue_t h2_outputVarName = {REGISTER, 'i', 1, 32, 3, 0};
	h2_sValue_t r = {REGISTER, 'i', 1, 32, 14, 0};
	h2_sValue_t h2_00000000 = {REGISTER, 'i', 1, 32, 15, 0};
	h2_sValue_t h2_00000001 = {REGISTER, 'i', 1, 32, 16, 0};


/* Label  table :*/
#define power_genLABEL(LABEL_ID) labelAddresses[LABEL_ID] = h2_asm_pc;
h2_insn_t   * labelAddresses []={
	};


	h2_asm_pc = (h2_insn_t *) ptr;
	h2_codeGenerationOK = 1;
	power_genMV_2(h2_00000000, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, 9});
	power_genMUL_3(h2_00000000, a, h2_00000000);
	power_genMV_2(h2_00000001, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, 5});
	power_genDIV_3(h2_00000000, h2_00000000, h2_00000001);
	power_genMV_2(h2_00000001, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, 32});
	power_genADD_3(h2_00000000, h2_00000000, h2_00000001);
	power_genMV_2(r, h2_00000000);
	power_genMV_2(h2_outputVarName, r);
	power_genRET_0();
	/* Call back code for loops */
	h2_save_asm_pc = h2_asm_pc;
	h2_asm_pc = h2_save_asm_pc;
	iflush(ptr, h2_asm_pc);

  return (h2_insn_t *) ptr;
}

h2_insn_t * genF2C(h2_insn_t * ptr)
{
/* Code Generation of 3 instructions */
/* Symbol table :*/
	/*VarName = { ValOrLen, arith, vectorLen, wordLen, regNo, Value} */
	h2_sValue_t a = {REGISTER, 'i', 1, 32, 3, 0};
	h2_sValue_t h2_outputVarName = {REGISTER, 'i', 1, 32, 3, 0};
	h2_sValue_t r = {REGISTER, 'i', 1, 32, 14, 0};
	h2_sValue_t h2_00000000 = {REGISTER, 'i', 1, 32, 15, 0};
	h2_sValue_t h2_00000001 = {REGISTER, 'i', 1, 32, 16, 0};


/* Label  table :*/
#define power_genLABEL(LABEL_ID) labelAddresses[LABEL_ID] = h2_asm_pc;
h2_insn_t   * labelAddresses []={
	};


	h2_asm_pc = (h2_insn_t *) ptr;
	h2_codeGenerationOK = 1;
	power_genMV_2(h2_00000000, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, 160});
	power_genMV_2(h2_00000001, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, 9});
	power_genDIV_3(h2_00000000, h2_00000000, h2_00000001);
	power_genSUB_3(h2_00000000, a, h2_00000000);
	power_genMV_2(r, h2_00000000);
	power_genMV_2(h2_outputVarName, r);
	power_genRET_0();
	/* Call back code for loops */
	h2_save_asm_pc = h2_asm_pc;
	h2_asm_pc = h2_save_asm_pc;
	iflush(ptr, h2_asm_pc);

  return (h2_insn_t *) ptr;
}


int main(int argc, char * argv[])
{
  h2_insn_t * ptr;
  int in0, res, resultOK;
  pifi fC2F, fF2C;

  resultOK = 0;
  if (argc < 2)
    {
      printf("Give 1 values\n");
      exit(-1);
    }
  in0  = atoi (argv[1]);   // Get the users values in0
  printf("// Compilette for conversion from celcius to farenheit\n");
  ptr  = h2_malloc (1024);  // Allocate memory for 1024 instructions
  fC2F = (pifi) genC2F (ptr); //
  res  = fC2F(in0);  // Call generated code
  printf("%d (celcius)   -> (farenheit)%d\n", in0, res);
  if (res != (in0 * 9 / 5 + 32))
	resultOK += 1;
  printf("// Compilette for conversion from farenheit to celcius\n");
  ptr  = h2_malloc (1024);  // Allocate memory for 1024 instructions
  fF2C = (pifi) genF2C (ptr); //
  res  = fF2C(in0);  // Call generated code
  printf("%d (farenheit)   -> (celcius)%d\n", in0, res);
  if (res != (in0 - 32 * 5 / 9))
	resultOK += 1;

  if (resultOK == 0)
	return 0;
  else
	return -1;
}
