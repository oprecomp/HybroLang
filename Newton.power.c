/* Begin Header autogenerated part */
#include "h2-power-power.h"
#define power_G32(INSN){ *(h2_asm_pc++) = (INSN);}

void P1_BLR__I_32(void){ /* ret */
#ifdef H2_DEBUG
    printf("%p : P1_BLR__I_32\n", h2_asm_pc);
#endif
	power_G32(((0x4e800020 >> 0) & 0xffffffff)); \
}  

void PPC_FADDS_RRR_F_32(int r0, int r1, int r2){ /* add */
#ifdef H2_DEBUG
    printf("%p : PPC_FADDS_RRR_F_32\n", h2_asm_pc);
#endif
	power_G32(((0x3b & 0x3f) << 26)|((r0 & 0x1f) << 21)|((r1 & 0x1f) << 16)|((r2 & 0x1f) << 11)|((0x2a & 0x7ff) >> 0)); \
}  

void PPC_FADDS__RRR_F_32(int r0, int r1, int r2){ /* add */
#ifdef H2_DEBUG
    printf("%p : PPC_FADDS__RRR_F_32\n", h2_asm_pc);
#endif
	power_G32(((0x3b & 0x3f) << 26)|((r0 & 0x1f) << 21)|((r1 & 0x1f) << 16)|((r2 & 0x1f) << 11)|((0x2b & 0x7ff) >> 0)); \
}  

void V2_03_VADDFP_RRR_F_32(int r0, int r1, int r2){ /* add */
#ifdef H2_DEBUG
    printf("%p : V2_03_VADDFP_RRR_F_32\n", h2_asm_pc);
#endif
	power_G32(((0x4 & 0x3f) << 26)|((r0 & 0x1f) << 21)|((r1 & 0x1f) << 16)|((r2 & 0x1f) << 11)|((0xa & 0x7ff) >> 0)); \
}  

void P1_FADD_RRR_F_64(int r0, int r1, int r2){ /* add */
#ifdef H2_DEBUG
    printf("%p : P1_FADD_RRR_F_64\n", h2_asm_pc);
#endif
	power_G32(((0x3f & 0x3f) << 26)|((r0 & 0x1f) << 21)|((r1 & 0x1f) << 16)|((r2 & 0x1f) << 11)|((0x2a & 0x7ff) >> 0)); \
}  

void P1_FADD__RRR_F_64(int r0, int r1, int r2){ /* add */
#ifdef H2_DEBUG
    printf("%p : P1_FADD__RRR_F_64\n", h2_asm_pc);
#endif
	power_G32(((0x3f & 0x3f) << 26)|((r0 & 0x1f) << 21)|((r1 & 0x1f) << 16)|((r2 & 0x1f) << 11)|((0x2b & 0x7ff) >> 0)); \
}  

void P1_FMR_RR_F_32(int r0, int r1){ /* mv */
#ifdef H2_DEBUG
    printf("%p : P1_FMR_RR_F_32\n", h2_asm_pc);
#endif
	power_G32(((0x3f & 0x3f) << 26)|((r0 & 0x1f) << 21)|((0x0 & 0x1f) << 16)|((r1 & 0x1f) << 11)|((0x90 & 0x7ff) >> 0)); \
}  

void P1_FMR_RR_F_64(int r0, int r1){ /* mv */
#ifdef H2_DEBUG
    printf("%p : P1_FMR_RR_F_64\n", h2_asm_pc);
#endif
	power_G32(((0x3f & 0x3f) << 26)|((r0 & 0x1f) << 21)|((0x0 & 0x1f) << 16)|((r1 & 0x1f) << 11)|((0x90 & 0x7ff) >> 0)); \
}  

void PPC_FDIVS_RRR_F_32(int r0, int r1, int r2){ /* div */
#ifdef H2_DEBUG
    printf("%p : PPC_FDIVS_RRR_F_32\n", h2_asm_pc);
#endif
	power_G32(((0x3b & 0x3f) << 26)|((r0 & 0x1f) << 21)|((r1 & 0x1f) << 16)|((r2 & 0x1f) << 11)|((0x24 & 0x7ff) >> 0)); \
}  

void P1_FDIV_RRR_F_64(int r0, int r1, int r2){ /* div */
#ifdef H2_DEBUG
    printf("%p : P1_FDIV_RRR_F_64\n", h2_asm_pc);
#endif
	power_G32(((0x3f & 0x3f) << 26)|((r0 & 0x1f) << 21)|((r1 & 0x1f) << 16)|((r2 & 0x1f) << 11)|((0x24 & 0x7ff) >> 0)); \
}  
void power_genADD_3(h2_sValue_t P0, h2_sValue_t P1, h2_sValue_t P2)
{

    if ((P0.arith == 'f') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
        PPC_FADDS_RRR_F_32(P0.regNro, P1.regNro, P2.regNro);
    }
    
    else if ((P0.arith == 'f') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
        PPC_FADDS__RRR_F_32(P0.regNro, P1.regNro, P2.regNro);
    }
    
    else if ((P0.arith == 'f') && (P0.wLen <= 32) && (P0.vLen == 4) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
        V2_03_VADDFP_RRR_F_32(P0.regNro, P1.regNro, P2.regNro);
    }
    
    else if ((P0.arith == 'f') && (P0.wLen <= 64) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
        P1_FADD_RRR_F_64(P0.regNro, P1.regNro, P2.regNro);
    }
    
    else if ((P0.arith == 'f') && (P0.wLen <= 64) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
        P1_FADD__RRR_F_64(P0.regNro, P1.regNro, P2.regNro);
    }
    
    else
    {
        printf("Warning, generation of ADD is not possible with this arguments P0: %c, %i, %i,  P0: %i , P1: %i , P2: %i \n", P0.arith, P0.wLen, P0.vLen, P0.ValOrReg ,P1.ValOrReg ,P2.ValOrReg);
        h2_codeGenerationOK = 0;
    }
}
void power_genMV_2(h2_sValue_t P0, h2_sValue_t P1)
{

    if ((P0.arith == 'f') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER)
    {
        P1_FMR_RR_F_32(P0.regNro, P1.regNro);
    }
    
    else if ((P0.arith == 'f') && (P0.wLen <= 64) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER)
    {
        P1_FMR_RR_F_64(P0.regNro, P1.regNro);
    }
    
    else
    {
        printf("Warning, generation of MV is not possible with this arguments P0: %c, %i, %i,  P0: %i , P1: %i \n", P0.arith, P0.wLen, P0.vLen, P0.ValOrReg ,P1.ValOrReg);
        h2_codeGenerationOK = 0;
    }
}
void power_genDIV_3(h2_sValue_t P0, h2_sValue_t P1, h2_sValue_t P2)
{

    if ((P0.arith == 'f') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
        PPC_FDIVS_RRR_F_32(P0.regNro, P1.regNro, P2.regNro);
    }
    
    else if ((P0.arith == 'f') && (P0.wLen <= 64) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
        P1_FDIV_RRR_F_64(P0.regNro, P1.regNro, P2.regNro);
    }
    
    else
    {
        printf("Warning, generation of DIV is not possible with this arguments P0: %c, %i, %i,  P0: %i , P1: %i , P2: %i \n", P0.arith, P0.wLen, P0.vLen, P0.ValOrReg ,P1.ValOrReg ,P2.ValOrReg);
        h2_codeGenerationOK = 0;
    }
}
void power_genRET_0()
{

    P1_BLR__I_32();

}

/* End Header autogenerated part */
/* -*- c -*- */

#include <stdio.h>
#include <stdlib.h>

typedef  float  (*piff)(float,  float,  float);
typedef  double (*pidd)(double, double, double);
#define True 1
#define False 0
#define FLOAT 32
#define DOUBLE 64


/* Newton square root demonstration with variable precision */
h2_insn_t * genIterate(h2_insn_t * ptr, int FloatWidth)
{
/* Code Generation of 4 instructions */
/* Symbol table :*/
	/*VarName = { ValOrLen, arith, vectorLen, wordLen, regNo, Value} */
	h2_sValue_t u = {REGISTER, 'f', 1, (FloatWidth), 1, 0};
	h2_sValue_t val = {REGISTER, 'f', 1, (FloatWidth), 2, 0};
	h2_sValue_t div = {REGISTER, 'f', 1, (FloatWidth), 3, 0};
	h2_sValue_t h2_outputVarName = {REGISTER, 'f', 1, (FloatWidth), 1, 0};
	h2_sValue_t r = {REGISTER, 'f', 1, (FloatWidth), 14, 0};
	h2_sValue_t tmp1 = {REGISTER, 'f', 1, (FloatWidth), 15, 0};
	h2_sValue_t tmp2 = {REGISTER, 'f', 1, (FloatWidth), 16, 0};
	h2_sValue_t h2_00000000 = {REGISTER, 'f', 1, (FloatWidth), 17, 0};


/* Label  table :*/
#define power_genLABEL(LABEL_ID) labelAddresses[LABEL_ID] = h2_asm_pc;
h2_insn_t   * labelAddresses []={
	};


	h2_asm_pc = (h2_insn_t *) ptr;
	h2_codeGenerationOK = 1;
	power_genDIV_3(h2_00000000, val, u);
	power_genMV_2(tmp1, h2_00000000);
	power_genADD_3(h2_00000000, u, tmp1);
	power_genMV_2(tmp2, h2_00000000);
	power_genDIV_3(h2_00000000, tmp2, div);
	power_genMV_2(h2_outputVarName, h2_00000000);
	power_genRET_0();
	/* Call back code for loops */
	h2_save_asm_pc = h2_asm_pc;
	h2_asm_pc = h2_save_asm_pc;
	iflush(ptr, h2_asm_pc);
 	  /* r = (u + (#(value) / u))  / 2.0*/

  return (h2_insn_t *) ptr;
}

#define ABS(x) ((x < 0) ? -(x) : (x))

int main(int argc, char **argv)
{
    int a, isFloat, iterationNumber;
    double af, precf, precd, value, next, diff;
    piff fPtr1;
    pidd fPtr2;
    h2_insn_t * ptr;
    char input;
    if (argc < 3)
    {
	printf ("Newton <value> <precision>\n");
	exit(-1);
    }
    iterationNumber = 0;
    a =  atoi (argv[1]);
    af = atof (argv[1]);
    precd = atof (argv[2]);
    precf = precd * 1.e14;
    ptr  = h2_malloc (1024);
    isFloat = True;
    printf ("Compute square root of %f\n", af);
    printf ("With precision of %e (float)\n", precf);
    printf ("With precision of %e (double)\n", precd);
    next = 1.0;
    diff = af;

    fPtr1 = (piff) genIterate (ptr, FLOAT);
    do
    {
	if ((diff < precf) && isFloat)
	{ 		/* Code re-generation with double for better precision */
	    fPtr2 = (pidd) genIterate (ptr, DOUBLE);
	    isFloat = False;
	}
	value = next;
	next = (isFloat)?fPtr1(value, af, 2.0):fPtr2(value, af, 2.0);
	diff = ABS(next - value);
	printf("%3d %s : %.20f, %e\n",
	       iterationNumber++,
	       isFloat?"float ":"double",
	       next, isFloat?precf:precd);
    } while ( isFloat || (!isFloat && (diff > precd)));
    return 0;
}
