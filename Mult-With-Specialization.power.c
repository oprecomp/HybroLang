/* Begin Header autogenerated part */
#include "h2-power-power.h"
#define power_G32(INSN){ *(h2_asm_pc++) = (INSN);}

void P1_BLR__I_32(void){ /* ret */
#ifdef H2_DEBUG
    printf("%p : P1_BLR__I_32\n", h2_asm_pc);
#endif
	power_G32(((0x4e800020 >> 0) & 0xffffffff)); \
}  

void P1_MULLW_RRR_I_32(int r0, int r1, int r2){ /* mul */
#ifdef H2_DEBUG
    printf("%p : P1_MULLW_RRR_I_32\n", h2_asm_pc);
#endif
	power_G32(((0x1f & 0x3f) << 26)|((r0 & 0x1f) << 21)|((r1 & 0x1f) << 16)|((r2 & 0x1f) << 11)|((0x1d6 & 0x7ff) >> 0)); \
}  

void P1_MULLI_RRI_I_64(int r0, int r1, int i0){ /* mul */
#ifdef H2_DEBUG
    printf("%p : P1_MULLI_RRI_I_64\n", h2_asm_pc);
#endif
	power_G32(((0x7 & 0x3f) << 26)|((r0 & 0x1f) << 21)|((r1 & 0x1f) << 16)|((i0 & 0xffff) >> 0)); \
}  

void P1_LI_RI_I_32(int r0, int i0){ /* mv */
#ifdef H2_DEBUG
    printf("%p : P1_LI_RI_I_32\n", h2_asm_pc);
#endif
	power_G32(((0xe & 0x3f) << 26)|((r0 & 0x1f) << 21)|((0x0 & 0x1f) << 16)|((i0 & 0xffff) >> 0)); \
}  

void P1_MV_RR_I_32(int r0, int r1){ /* mv */
#ifdef H2_DEBUG
    printf("%p : P1_MV_RR_I_32\n", h2_asm_pc);
#endif
	power_G32(((0xe & 0x3f) << 26)|((r0 & 0x1f) << 21)|((r1 & 0x1f) << 16)|((0x0 & 0xffff) >> 0)); \
}  
void power_genRET_0()
{

    P1_BLR__I_32();

}
void power_genMUL_3(h2_sValue_t P0, h2_sValue_t P1, h2_sValue_t P2)
{

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == REGISTER)
    {
        P1_MULLW_RRR_I_32(P0.regNro, P1.regNro, P2.regNro);
    }
    
    else if ((P0.arith == 'i') && (P0.wLen <= 64) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER && P2.ValOrReg == VALUE)
    {
        P1_MULLI_RRI_I_64(P0.regNro, P1.regNro, P2.valueImm);
    }
    
    else
    {
        printf("Warning, generation of MUL is not possible with this arguments P0: %c, %i, %i,  P0: %i , P1: %i , P2: %i \n", P0.arith, P0.wLen, P0.vLen, P0.ValOrReg ,P1.ValOrReg ,P2.ValOrReg);
        h2_codeGenerationOK = 0;
    }
}
void power_genMV_2(h2_sValue_t P0, h2_sValue_t P1)
{

    if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == VALUE)
    {
        P1_LI_RI_I_32(P0.regNro, P1.valueImm);
    }
    
    else if ((P0.arith == 'i') && (P0.wLen <= 32) && (P0.vLen == 1) && P0.ValOrReg == REGISTER && P1.ValOrReg == REGISTER)
    {
        P1_MV_RR_I_32(P0.regNro, P1.regNro);
    }
    
    else
    {
        printf("Warning, generation of MV is not possible with this arguments P0: %c, %i, %i,  P0: %i , P1: %i \n", P0.arith, P0.wLen, P0.vLen, P0.ValOrReg ,P1.ValOrReg);
        h2_codeGenerationOK = 0;
    }
}

/* End Header autogenerated part */
// -*- c -*-
#include <stdio.h>
#include <stdlib.h>

typedef  int (*pifi)(int);

h2_insn_t * genMult(h2_insn_t * ptr, int  b)
{
/* Code Generation of 3 instructions */
/* Symbol table :*/
	/*VarName = { ValOrLen, arith, vectorLen, wordLen, regNo, Value} */
	h2_sValue_t a = {REGISTER, 'i', 1, 32, 3, 0};
	h2_sValue_t h2_outputVarName = {REGISTER, 'i', 1, 32, 3, 0};
	h2_sValue_t r = {REGISTER, 'i', 1, 32, 14, 0};
	h2_sValue_t h2_00000000 = {REGISTER, 'i', 1, 32, 15, 0};


/* Label  table :*/
#define power_genLABEL(LABEL_ID) labelAddresses[LABEL_ID] = h2_asm_pc;
h2_insn_t   * labelAddresses []={
	};


	h2_asm_pc = (h2_insn_t *) ptr;
	h2_codeGenerationOK = 1;
	power_genMV_2(h2_00000000, (h2_sValue_t) {VALUE, 'i', 1, 32, 0, (b)});
	power_genMUL_3(h2_00000000, h2_00000000, a);
	power_genMV_2(r, h2_00000000);
	power_genMV_2(h2_outputVarName, r);
	power_genRET_0();
	/* Call back code for loops */
	h2_save_asm_pc = h2_asm_pc;
	h2_asm_pc = h2_save_asm_pc;
	iflush(ptr, h2_asm_pc);

  return (h2_insn_t *) ptr;
}


int main(int argc, char * argv[])
{
  h2_insn_t * ptr;
  int in0, in1, res;
  pifi fPtr;


  if (argc < 3)
    {
      printf("Give 2 values\n");
      exit(-1);
    }
  in0  = atoi (argv[1]);   // Get the users values in1 & in2
  in1  = atoi (argv[2]);
  ptr  = h2_malloc (1024);  // Allocate memory for 1024 instructions
  printf("// Compilette for simple addition between 1 variable with\n");
  printf("// code specialization on value = %d\n", in0);
  fPtr = (pifi) genMult (ptr, in0); // Generate instructions
  res  = fPtr(in1);  // Call generated code
  printf("%d * %d = %d\n", in0, in1, res);
  if (res == (in0 * in1))
    return 0;
  else
    return -1;
}
